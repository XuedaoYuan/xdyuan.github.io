(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{466:function(t,e,s){t.exports=s.p+"assets/img/1.317ee921.jpg"},563:function(t,e,s){"use strict";s.r(e);var a=s(58),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"关于http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关于http"}},[t._v("#")]),t._v(" 关于HTTP")]),t._v(" "),a("p",[t._v("主要是了解一些关于http的基础知识，毕竟这个知识点展开的话内容确实很多。主要是我们工作当中可能会用到的一些概念，面试中可能会问的一些基础知识点。")]),t._v(" "),a("p",[t._v("首先知道http是什么， 用来做什么我觉得就足够了。能知道面试问的一些基本概念吧")]),t._v(" "),a("p",[a("strong",[t._v("超文本传输协议")]),t._v("（HTTP）是一个用于传输超媒体文档的应用层协议。主要可以用于浏览器和服务端通信，HTTP 遵循经典的客户端-服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应。HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。尽管通常基于 TCP/IP 层，但它可以在任何可靠的传输层上使用。")]),t._v(" "),a("h4",{attrs:{id:"一个http请求的组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个http请求的组成"}},[t._v("#")]),t._v(" 一个HTTP请求的组成")]),t._v(" "),a("div",{staticClass:"language-http extra-class"},[a("pre",{pre:!0,attrs:{class:"language-http"}},[a("code",[a("span",{pre:!0,attrs:{class:"token request-line"}},[a("span",{pre:!0,attrs:{class:"token method property"}},[t._v("POST")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token request-target url"}},[t._v("/login")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token header"}},[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("HOST")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("xdyuan.cn")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token header"}},[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept-Language")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("zh")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token header"}},[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("content-type")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("application/json;charset=UTF-8")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token header"}},[a("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("authorization")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("token")])]),t._v('\n\n{"username": "xxx"}\n')])])]),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("请求方法 空格 路径path HTTP/版本号 回车换行\n多个头部\n添加空行\n请求体\n")])])]),a("h4",{attrs:{id:"一个http-response"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一个http-response"}},[t._v("#")]),t._v(" 一个HTTP response")]),t._v(" "),a("p",[t._v("偷个懒")]),t._v(" "),a("p",[a("img",{attrs:{src:s(466),alt:""}})]),t._v(" "),a("h4",{attrs:{id:"http连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http连接"}},[t._v("#")]),t._v(" HTTP连接")]),t._v(" "),a("p",[t._v("一个连接是由传输层来控制的，这从根本上不属于HTTP的范围。HTTP并不需要其底层的传输层协议是面向连接的，只需要它是可靠的，或不丢失消息的（至少返回错误）。在互联网中，有两个最常用的传输层协议：TCP是可靠的，而UDP不是。因此，"),a("strong",[t._v("HTTP依赖于面向连接的TCP进行消息传递")]),t._v("，但连接并不是必须的。")]),t._v(" "),a("p",[t._v("在客户端（通常指浏览器）与服务器能够交互（客户端发起请求，服务器返回响应）之前，必须在这两者间建立一个 TCP 链接，打开一个 TCP 连接需要多次往返交换消息（因此耗时）。HTTP/1.0 默认为每一对 HTTP 请求/响应都打开一个单独的 TCP 连接。当需要连续发起多个请求时，这种模式比多个请求共享同一个 TCP 连接更低效。")]),t._v(" "),a("p",[t._v("为了减轻这些缺陷，HTTP/1.1引入了流水线（被证明难以实现）和持久连接的概念：底层的TCP连接可以通过"),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Connection",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("Connection")]),a("OutboundLink")],1),t._v("头部来被部分控制。HTTP/2则发展得更远，通过在一个连接复用消息的方式来让这个连接始终保持为暖连接。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[a("strong",[t._v("Connection")]),t._v(" 头（header） 决定当前的事务完成后，是否会关闭网络连接。如果该值是“keep-alive”，网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成。")])]),t._v(" "),a("h4",{attrs:{id:"基于http的前端js-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于http的前端js-api"}},[t._v("#")]),t._v(" 基于HTTP的前端js api")]),t._v(" "),a("p",[t._v("基于HTTP的最常用API是 XMLHttpRequest API，可用于在user agent和服务器之间交换数据。 现代Fetch API提供相同的功能，具有更强大和灵活的功能集。")]),t._v(" "),a("p",[t._v("另一种API，即服务器发送的事件，是一种单向服务，允许服务器使用HTTP作为传输机制向客户端发送事件。 使用"),a("code",[t._v("EventSource")]),t._v("接口，客户端打开连接并建立事件句柄。 客户端浏览器自动将到达HTTP流的消息转换为适当的"),a("code",[t._v("Event")]),t._v("对象，并将它们传递给专门处理这类"),a("code",[t._v("type")]),t._v("事件的句柄，如果有这么个句柄的话。但如果相应的事件处理句柄根本没有建立，那就交给"),a("code",[t._v("onmessage")]),t._v("事件处理程序处理。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("服务端可以单向推送事件流的这么一个技术，用在一些看板刷新应该会比较合适。应该是比较轻量级的那种文本流推送功能。")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Server-sent_events/Using_server-sent_events",target:"_blank",rel:"noopener noreferrer"}},[t._v("EventSource"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("可惜没有实践的机会，后续可以尝试用node实践一些demo。"),a("a",{attrs:{href:"https://www.cnblogs.com/naturl/p/15049186.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考看看"),a("OutboundLink")],1)])]),t._v(" "),a("p",[t._v("HTTP是一种简单可扩展的协议，其Client-Server的结构以及轻松扩展头部信息的能力使得HTTP可以和Web共同发展。")]),t._v(" "),a("p",[t._v("即使HTTP/2为了提高性能将HTTP报文嵌入到帧中这一举措增加了复杂度，但是从Web应用的角度看，报文的基本结构没有变化，从HTTP/1.0发布起就是这样的结构。")]),t._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[t._v("DANGER")]),t._v(" "),a("p",[t._v("以上内容只是自己的学习记录， 更全面的内容还是参考更官方的文档合理")])])])}),[],!1,null,null,null);e.default=r.exports}}]);